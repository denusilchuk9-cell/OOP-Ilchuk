# Лабораторна робота 3: Принципи ISP та DIP

## Принцип розділення інтерфейсів (ISP)

### Проблема порушення ISP
У проєкті `ISP_Violation` створено інтерфейс `IWorker`, який містить занадто багато методів. Це призводить до того, що клас `Programmer` змушений реалізовувати методи, які йому не потрібні (наприклад, `Design()`, `Test()`, `Deploy()`).

### Рішення проблеми
У проєкті `ISP_Solution` ми розділили великий інтерфейс на декілька вузьких:
- `IWorkable` - тільки робота
- `IEatable` - тільки їжа
- `ISleepable` - тільки сон
- `ICodeable` - тільки кодування

Це дозволяє класам реалізовувати лише ті інтерфейси, які їм дійсно потрібні.

## Принцип інверсії залежностей (DIP)

### Переваги Dependency Injection
У проєкті `DIP_Demo` показано переваги DIP:

1. **Гнучкість**: Можна легко змінювати реалізацію логера (ConsoleLogger або FileLogger)
2. **Тестованість**: Можна використовувати mock-об'єкти для тестування
3. **Розширюваність**: Легко додати нові типи логерів
4. **Слабке зв'язування**: Класи залежать від абстракцій, а не від конкретних реалізацій

### Як вузькі інтерфейси (ISP) сприяють кращому DI та тестуванню

1. **Краща композиція**: Вузькі інтерфейси дозволяють точніше компонувати залежності
2. **Легше мокування**: Менші інтерфейси простіше мокувати в тестах
3. **Чіткіші контракти**: Кожен інтерфейс має одну відповідальність
4. **Гнучкість залежностей**: Можна ін'єктувати лише ті залежності, які дійсно потрібні

### Приклад DI з вузькими інтерфейсами:
```csharp
public class ReportGenerator
{
    private readonly IDataReader _reader;
    private readonly IDataFormatter _formatter;
    private readonly IDataExporter _exporter;
    
    public ReportGenerator(IDataReader reader, IDataFormatter formatter, IDataExporter exporter)
    {
        _reader = reader;
        _formatter = formatter;
        _exporter = exporter;
    }
}

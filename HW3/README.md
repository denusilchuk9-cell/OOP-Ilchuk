1. Принцип розділення інтерфейсів (ISP)
У проєкті було створено "товстий" інтерфейс IWorker, який містив сім методів: Work, Eat, Sleep, Code, Design, Test та Deploy. Це призвело до того, що клас Programmer був змушений реалізовувати всі ці методи, хоча йому потрібні були лише чотири з них. Методи Design, Test та Deploy довелося реалізувати з викиданням винятків, що є явною ознакою поганого дизайну. Такий підхід порушує принцип розділення інтерфейсів, оскільки клас залежить від методів, які він не використовує.

Вирішенням проблеми стало розділення великого інтерфейсу на декілька вузьких, спеціалізованих інтерфейсів: IWorkable, IEatable, ISleepable, ICodeable та ITestable. Тепер клас Programmer реалізує лише ті інтерфейси, які йому дійсно потрібні, а клас Tester, наприклад, реалізує IWorkable, IEatable, ISleepable та ITestable. Це дозволяє уникнути ситуацій, коли класи змушені реалізовувати непотрібні методи.

2. Принцип інверсії залежностей (DIP)
Для демонстрації принципу інверсії залежностей було створено абстракцію ILogger з методом Log. Дві конкретні реалізації цього інтерфейсу - ConsoleLogger та FileLogger - виконують логування у консоль та у файл відповідно. Високорівневий модуль UserService отримує логер через конструктор, залежачи виключно від абстракції ILogger, а не від конкретних реалізацій.

Застосування DIP через Dependency Injection дає кілька важливих переваг. По-перше, це гнучкість - можна легко замінити одну реалізацію логера на іншу без зміни коду UserService. По-друге, це тестованість - при написанні юніт-тестів можна використовувати mock-об'єкти замість реальних логерів. По-третє, досягається слабке зв'язування між компонентами системи, що робить код більш підтримуваним.

3. Вплив ISP на Dependency Injection та тестування
Вузькі інтерфейси, створені відповідно до принципу ISP, значно полегшують застосування Dependency Injection та тестування. Коли кожен інтерфейс має чітко визначену відповідальність, стає простіше зрозуміти, які саме залежності потрібні класу. Це дозволяє створювати більш точні та зрозумілі конструктори.

При тестуванні класів з вузькими інтерфейсами набагато легше створювати mock-об'єкти, оскільки кожен інтерфейс містить невелику кількість методів. Наприклад, якщо клас залежить тільки від IDataReader та IDataFormatter, то в тестах можна легко замокати саме ці два невеликі інтерфейси, а не великий "товстий" інтерфейс з багатьма методами.

Таким чином, поєднання принципів ISP та DIP дозволяє створюти гнучку, розширювану архітектуру, яка легко піддається тестуванню та модифікації. Код стає чистішим, зрозумілішим і більш відповідає принципам об'єктно-орієнтованого програмування.
